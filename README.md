# GitAnalyzer

**GitAnalyzer** is a tool finding the code, design and project management issues by using the behavioral analysis metrics on Git repository. From practice, project managers love the GitAnalyzer at first sight.

![ui-view](/screenshots/ui-view.png)

This tool is inspired by the book of "[Your Code as a Crime Scene](https://pragprog.com/book/atcrime/your-code-as-a-crime-scene)" by Adam Tornhill. This book has great proposals of behavioral analysis on version control repositories, and GitAnalyzer takes the best of them (little bit rethought to don't rely on actual code). The main idea permeating this tool is that you don't need to spend hours doing static code analysis. You have all the information in your Git repository. Just look how your team behaves with each its part.

Reason to build GitAnalyzer is making a repository analysis tool with convenient user interface and easy to change.

## Non-functional features

- Works with several Git repositories and merging the statistics from all of them.
- Supports multi-team and multi-location projects
- Supports incremental updates to support up-to-date information without any manual actions.
- Caches the statistics in memory within uptime. Caches statistics to disk to decrease network communications in startup.

### Basic concepts

- **Change**. In GitAnalyzer the change is an atomic unit of measurement. Change here is a commit made to the single file by the single author within the single task. Change is a fractional value: e.g. if 4 commits made in same task for same file by the same author each commit will represent 0.25 part of this change. So amount of changes can be fractional.
- **Task**. Some commits are just continuous commits related to same task. Weight of such commits should be distributed across themselves. Currently we can only keep track of tasks using the comments of commits. You specify the prefix of the JIRA by special property, and system will group all the commits related to the same JIRA number.
- **Files and modules**. File is a source file in file system. Module is a root directory for source subtree acting as a separate unit. GitAnalyzer finds modules by existance of the build descriptor in a root directory of module, or by existance of sub-directory "src."
- **Author**. Author is an actual author in Git, not a committer. Author is identified by couple Name-E-mail. Author should represent a single person. When you have a situation when some person has several names/e-mails, You can unite them all via the property file by declaring them as aliases. All contribution made from these aliases will be grouped to the single author then.
- **Filtering**. Some commits are undesirable in metrics. These are: service commits, commits made by scripts, merge commits and commits generated by git-rebase. Build descriptors are also undesirable in some metrics (e.g. dependency graph). These files and commits are filtered out and don't appear in results.

### Application modes

GitAnalyzer can be run as either a server or a standalone client. There are 3 startup modes for it:
1. **Server mode**. It starts a Java process on the server machine and provides an HTTP interface for thin client. GitAnalyzer performs the incremental updates in background to make the data always up-to-date. To run application in server mode use command-line parameter ```-server```.
2. **Client mode**. It starts a Java process with reduced server as well as a client browser. When user closes the browser the server shuts down. Statistics gathering performs once. To run application in client mode use command-line parameter ```-client``` or without parameters. This is a default mode.
3. **Installation mode**. It starts in command-line mode, installs the application to directory you specified, and gives up. To install the application use command-line parameter ```-install```.

## Collected metrics

*All examples are made on base of Hibernate repository as of Dec 04, 2016.*

### Maintenance cost

Every file in repository is being changed intermittently. Some files are changed much more often than others. These changes are often caused by bad design, complexity, tight coupling and other undesired factors. In ideal world we should have equal amount of changes distributed across the whole codebase.

Every change comes not for free for companies. They pay developers making these changes, QA testing regression, support, etc.. So, these undesired changes often take more than 80% of the project's cost.

In this metric, we calculate the amount of changes per file, then order them by descending, and draw a plot.

![lc-files-chart](/screenshots/lc-files-chart.png)

Integral value: area below the plot is the overall changes' cost in money. This area for top 5% files is the same as for all remaining files. And reducing this value can significantly reduce the maintenance cost of project.

A table below the plot shows the files to be addressed.

![lc-files-table](/screenshots/lc-files-table.png)

Table is ranged by changes percent. First column shows the absolute amount of changes, second is relative amount (%). Last two columns open the pop-up showing the authors and teams mostly contributing to this file. Red rows mark the files to address. They have ten times bigger amount than ideal. If Amount is above the ideal, the row is amber. Green rows are below the ideal.

This page also shows this metric on module basis.

![lc-modules-chart](/screenshots/lc-modules-chart.png)

![lc-modules-table](/screenshots/lc-modules-table.png)

### Merge bottlenecks

This metric shows files and modules changed by unique authors. The more autors some file (or module) has the more conflicts it produces at merge. Such files and modules are merge bottlenecks in project. Common advice here: introducing code ownership to codebase; looking where SRP principle is violated.

The first bar chart shows the top 30 modules by count of unique authors. Highest bars are merge bottlenecks to be addressed.

![mb-modules-chart](/screenshots/mb-modules-chart.png)

Tables below show the modules and files ordered by by count of unique authors.

![mb-modules-table](/screenshots/mb-modules-table.png)

![mb-files-table](/screenshots/mb-files-table.png)

Red rows are files (modules) with count > 100. Amber: > 20. Last two columns open the pop-up showing the authors and teams mostly contributing to the given file (module).

### Stability analysis

This is a temporal metric based on the first and last changes in files. Usually the file or module is being changed first 3 months. And then when application architecture stabilizes, it's kept untouched for years. But some files/modules are changing within all their lifetime. This is an indicator that architecture is unstable in these places. There could be another cause of that: some files/modules are changed often because of multiple change requests to corresponding functionality. This could be a management issue, or just a false positive result.

Scatter plot ranges all the modules by first and last commit. First change here is a first commit. Last change is a recent commit. X axis is a time between first and last commit. Y axis is a time sinse the last commit. We usually don't want to see X more than Y. So, the red zone shows all "unstable" modules. The farther point from the line y=x, the less stable the module's architecture. The hottest are in bottom-right corner.

![stability-modules-chart](/screenshots/stability-modules-chart.png)

Table below shows the detailed age information.

![stability-modules-table](/screenshots/stability-modules-table.png)

Age is a time from first change until now. Time from last change is self-descriptive.<br>
(*Stability %*) is (*Time from last change*) / (*Age*) * 100%.<br>
Red rows indicate *Stability* less than 20%. Amder: between 20% and 50%.

The same metrics is collected on the file basis.

![stability-files-table](/screenshots/stability-files-table.png)

### Activity analysis

This temporal metric shows the authors', teams' and whole project's activity on monthly basis. This metric can narrate many interesting stories above the project. For example, if some team has instantly decreasing line this could mean that team has either low motivation or some other factors preventing normal contribution. If the plot has waves that can mean that work is doing by raids: silent periods alternate with periods of rush. Sometimes contribution grows or falls significantly at a time, and it's interesting to find a cause of that.

![a-all](/screenshots/a-all.png)

![a-team](/screenshots/a-team.png)

![a-author](/screenshots/a-author.png)

X axis is a timeline quantized by months. Y axis is amount of changes.

### Implicit dependencies

This metric shows the actual dependencies between files or modules. Some dependencies are explicitly set and expected by design. For example, your web application depends on some library providing authorization. But some dependences are just wondering. For example, if change in database causes changes in UI module, this dependency is implicit and undesirable. Finding such dependencies is a complex task. But finding and decoupling them gets benefits in decreasing complexity of code. Such dependencies can be found by analyzing which files (modules) are often being changed together (i.e appear in the same commit.) Then we can build a graph of such files (modules) and find clusters in this graph.

![id-modules-graph](/screenshots/id-modules-graph.png)

Nodes are modules; edges are connections. Every node and edge of this graph is weighted. Weight of edge is a count of commits where two modules appeared together. Weight of node is a sum of all connecting edges. The higher weight the thicker lines. Edges having weight less than 3 are filtered out. Nodes having no edges are filtered out.

![id-files-table](/screenshots/id-files-table.png)

In this table: *count of connections* is a count of commits where two files appeared together. Rows with number less than 3 are filtered out. Rows are ordered by count of connections from greatest to least. First 10% of rows are red. Next 40% are amber.

### Contributors performance

This metric shows absolute and relative amount of changes per on team bases, on location basis and for every author individually. It can be used for team performance analysis only if all the people are doing very similar and routine work. Why? Because precision of this metric is arguable. It shows just a number of changes, but doesn't take complesxity of these changes into account. Currently so many non-measurable factors affect performance that we can say we have no precise metrics for that. All of them are just empirical.

Using the filtering by mask you can look who is contributing more to different file types. For example, who is writing unit tests and who is not. You can also filter by module path and look who is mostly contributing to particular file or module.
Performance by locations shows two maps. First map shows the absolute and relative amount of changes per location. Second map shows the efficiency: average amount of changes per author.

![c-locations-map](/screenshots/c-locations-map.png)
![c-locations-map-eff](/screenshots/c-locations-map-eff.png)

Performance by teams shows two bar charts. First chart shows the absolute and relative amount of changes per team. Second map shows the efficiency: average amount of changes per author.

![c-teams-chart](/screenshots/c-teams-chart.png)
![c-teams-chart-eff](/screenshots/c-teams-chart-eff.png)

Teams performance is also detailed in table.

![c-teams-table](/screenshots/c-teams-table.png)

In this table: *Count of changes* is absolute amount, *Summary contribution* is relative amount, and *Changes per member* is efficiency.

The last table shows the individual performance in absolute and relative numbers.

![c-authors-table](/screenshots/c-authors-table.png)

### Top contributors of the file/module

These tables show which teams and authors are mostly contributing to the module. It allows you find who is responsible for that file/module. Or who has bigger expertise of this file/module. This is useful when you want to get an advice or assistance, or assign some work to appropriate person.

![popup-topauthors-file](popup-topauthors-file.png)
![popup-topauthors-module](popup-topauthors-module.png)
![popup-topteams-file](popup-topteams-file.png)
![popup-topteams-module](popup-topteams-module.png)

These tables can be opened from links "*Authors*" and "*Teams*" wherever you find them in other tables.

### Top contribution of the author/team

These tables show which files and modules are mostly changed by the given team/author. In other words, who is the actual owner of particular code.

![popup-topfiles-author](popup-topfiles-author.png)
![popup-topfiles-team](popup-topfiles-team.png)
![popup-topmodules-author](popup-topmodules-author.png)
![popup-topmodules-team](popup-topmodules-team.png)

These tables can be opened from links "*Files*" and "*Modules*" wherever you find them in other tables.

## Additional features

Date and file path filtering

![form-filter](form-filter.png)

Search and export to CSV in tables

![form-search-export](form-search-export.png)


# Installation and configuration

## Prerequisites
- **Java 1.8** or higher should be installed.
- **Git** should be installed.
- **Repositories** must be checked out and connected to remotes.

## Installation

Download the JAR file and run<br>
```java -jar <path to JAR file> -install -configFolder="<path to configuration directory>" -cacheFolder="<path to cache directory>"```<br>
Parameters ```-configFolder``` and ```-cacheFolder``` are optional. If you skip them the default folders ```<path to JAR file>/conf``` and ```<path to JAR file>/cache``` will be created.<br>
Application should be manually configured after installation.

## Configuration

After installation, the configuration folder will contain 5 property files:

**1. application.properties**<br>
This file contains basic configuration of the application and processed data. It includes:
  - ```GIT.read.batch.size=<numeric value, default 1024>```. Mandatory.<br>
    When performing data gathering, GitAnalyzer creates about 16 threads reading the Git repository. This property specifies how many files should be processed by each thread. This property is equal to count of external requests done by each reader thread.
  - ```GIT.max.connection.attempts=<numeric value, default 5>```. Mandatory.<br>
    When performing data gathering, the particular command can fail due to network or remote server issue. GitAnalyzer re-attempts the connection to server in this case. This property specifies how many attempts will be made before GitAnalyzer gives up and fails the update process.
  - ```GIT.service.commit.markers=<comma separated list of string values>```<br>
    Some commits made to version control system are just service commits. These are commits like "bump up snapshot version", "migration from other VCS", etc. Service commits should be filtered out and do not take part in analysis. You specify the list of string values in this property. If commit has any of these values in description it's being matched as a "service commit" and filtered out.
  - ```GIT.service.author.markers=<comma separated list of author names>```<br>
    Some authors are just service authors. They do not reflect real developers and just reflects the scripts used within the build/deployment tasks. You can filter out all the contribution of such authors. You should specify names of them (not emails) separated by comma. Name should completely match the author name.
  - ```GIT.build.file.markers=<comma separated list of build descriptor files>```<br>
    Some files are service files used by the build automation tool. These are files like pom.xml, .gradle, etc. These files take part in some metrics, and excluded in some other. In addition, these files are sometimes used by GitAnalyzer as module separating markers. You can specify the comma-separated list of file names. All paths ending by these names will be marked as a "build descriptor file."
  - ```GIT.refactoring.commits.min.size=500```. Mandatory.<br>
    Some commits are really huge, but they have only minor changes. For example, if you renamed a single source file (which is referred from 1000 other source files), you have to change all these 1000. But the change in still minor. Some metrics should decrease the weight of such commits. So you can specify the threshold by this property. If commit has more files than threshold this commit is marked as "refactoring."
  - ```GIT.jira.prefix=<Jira prefix in format [A-Z]*-, for example: AAA->```<br>
    GIT doesn't keep the information about branches, so only we can do is relying on issue tracking system (like JIRA) and its internal numbers. If project has a policy to keep the task numbers in commit's comment we can group the commits with same task reference and then distribute the contribution weight.
  - ```GIT.repository.paths=<comma separated list of repository root paths>```. Mandatory.<br>
    List of repositories in file system (on same machine when you run the server.)
  - ```GIT.branch.names=<comma separated list of branch names>```. Mandatory.<br>
    List of branch names of repositories. This property should be parallel to "GIT.repository.paths" property: count of values should be equal. First value of one property should correspond to first value of other property. Second should correspond to second, and so forth. Recommended branches: develop for Git flow, master for other cases.
  - ```GIT.repository.filename.prefixes=<comma separated list of prefixes>```. Mandatory if there are more than one repository.<br>
    List of prefixes for filenames for each repository specified. All file paths in Git repository will be prefixed with single prefix in statistics. This property should be parallel to "GIT.repository.paths" property: count of values should be equal. First value of one property should correspond to first value of other property. Second should correspond to second, and so forth. Recommended branches: develop for Git flow, master for other cases.
  - ```GIT.log.min.date=<date in format YYYY-MM-dd>, for example: 2016-11-21 14:20:21```<br>
    Minimum date of commits. Only commits after this date will be analyzed. This can be used in single run (-client) mode.
  - ```GIT.log.max.date=<date in format YYYY-MM-dd>, for example: 2016-11-21 14:20:21>```<br>
    Maximum date of commits. Only commits before this date will be analyzed. This can be used in single run (-client) mode.
  - ```GIT.update.interval.hours=24```. Mandatory.<br>
    Interval between incremental updates. Value is in hours. Daily update is default.
  - ```HTTP.server.thread.count=10```. Mandatory.<br>
    Count of HTTP requests can be processed simultaneously.
  - ```HTTP.server.host=localhost```. Mandatory.<br>
    Server host. This setting is used in client mode.
  - ```HTTP.server.port=<numeric value, default 8000>```. Mandatory.<br>
    Server port.
  - ```HTTP.browser.path=<path to the browser executable file>```. Mandatory.<br>
    Path to browser. This setting is used in client mode.

  - ```FileAuthorsAnalyzer.min.authors.count=<numeric value, default 5>```. Mandatory.<br>
(and other similar settings) are used in analysis algorithms. Changing them is not recommended.

**2. author.emails.mapping.properties**<br>
It is not a rare situation when some person commits to Git from different accounts. This property file defines the mapping between real and alias author emails. All aliases will be grouped to real email. All commits made with alias email will be treated as made by single author.
Example:
```
author1.1@email.org=author1@email.org
author1.2@email.org=author1@email.org
```
All commits made by ```author1.1@email.org``` and ```author1.2@email.org``` will be joined with ```author1@email.org``` and treated as made by ```author1@email.org```.

**3. author.names.mapping.properties**<br>
It is not a rare situation when some person commits to Git from different accounts. This property file defines the mapping between real and alias author names. All aliases will be grouped to real name. All commits made with alias name will be treated as made by single author.
Example:
```
author1.1=Author 1
author1.2=Author 1
```
All commits made by ```author1.1``` and ```author1.2``` will be joined with ```Author 1``` and treated as made by ```Author 1```.

**4. locations.properties**<br>
Mapping ```<author email>=<location>```. Author email should not be an alias (see **author.emails.mapping.properties**). Location is a country abbreviation as per ISO 3166-1 alpha-2.

**5. teams.properties**<br>
Mapping ```<author email>=<team name>```. Author email should not be an alias (see author.emails.mapping.properties). Team name is any string value.

# For contributors

If you want to participate in this project, below is a brief description of its architecture and dependencies.

Dependencies:

- Java 1.8+, no other server-side runtime dependencies
- JUnit 4.12
- Lumino admin template
- Bootstrap 3
- Alchemy.js
- Chart.js 1.0.1, 2.3.0
- JQVMap 1.5.1
- JQuery 1.11.1, 2.2.4

Architecture:

![architecture](architecture.png)